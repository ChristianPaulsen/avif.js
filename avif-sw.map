{"version":3,"sources":["../avif-sw.js"],"names":["BOX_HEADER_SIZE","BOX_FTYP","BOX_META","BOX_ILOC","MOV_HEADER","b64","str","atob","len","length","u8","Uint8Array","i","charCodeAt","MOV_HEADER_SIZE","byteLength","MOV_STSZ_OFFSET","MOV_MDAT_OFFSET","taskById","taskCounter","assert","cond","Error","avif2mov","ab","obu2mov","obu","fileSize","ArrayBuffer","view","DataView","set","setUint32","avif2obu","getU8","v","getUint8","pos","getU16","getUint16","getU32","getUint32","brandsCheck","size","type","end","offsetSizeAndLengthSize","offsetSize","lengthSize","baseOffsetSize","baseOffset","extentOffset","extentLength","offset","subarray","self","addEventListener","e","msg","data","bmpArr","rgba2bmp","w","h","setU16","setUint16","setU32","headerSize","stride","Math","floor","pixelArraySize","fileLength","file","data32","Uint32Array","w3","pos32","y","shift","x","abgr","bg","r","setUint8","width","height","blob","Blob","res","Response","id","resolve","reject","clientId","request","url","match","respondWith","Promise","clients","get","then","client","decodeAvif","req","fetch","credentials","arrayBuffer","avifArr","movArr","postMessage","catch","err"],"mappings":"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","file":"avif-sw.map","sourceRoot":"../../home/kagami/code/avif.js/demo","sourcesContent":["(function() {\n\n// ISOBMFF constants.\nconst BOX_HEADER_SIZE = 8;\nconst BOX_FTYP = 0x66747970;\nconst BOX_META = 0x6d657461;\nconst BOX_ILOC = 0x696c6f63;\n\n// MOV container stub with single video track.\nconst MOV_HEADER = (function() {\n  const b64 = \"AAAAHGZ0eXBpc29tAAACAGlzb21pc28ybXA0MQAAAettb292AAAAbG12aGQAAAAAAAAAAAAAAAAAAAPoAAAAKgABAAABAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAABd3RyYWsAAABcdGtoZAAAAAMAAAAAAAAAAAAAAAEAAAAAAAAAKgAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAHgAAABDgAAAAAARNtZGlhAAAAIG1kaGQAAAAAAAAAAAAAAAAAAF3AAAAD6VXEAAAAAADrbWluZgAAAONzdGJsAAAAf3N0c2QAAAAAAAAAAQAAAG9hdjAxAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAB4AEOABIAAAASAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGP//AAAAGWF2MUOBCAwACgsAAABCq7/Dd//mAQAAABhzdHRzAAAAAAAAAAEAAAABAAAD6QAAABxzdHNjAAAAAAAAAAEAAAABAAAAAQAAAAEAAAAUc3RzegAAAAAAAAAAAAAAAQAAABRzdGNvAAAAAAAAAAEAAAIPAAAAAG1kYXQ=\";\n  const str = atob(b64);\n  const len = str.length;\n  const u8 = new Uint8Array(len);\n  for (let i = 0; i < len; i++) {\n    u8[i] = str.charCodeAt(i);\n  }\n  return u8;\n})();\nconst MOV_HEADER_SIZE = MOV_HEADER.byteLength;\nconst MOV_STSZ_OFFSET = 479;\nconst MOV_MDAT_OFFSET = 519;\n\n// Pending fetch events.\nconst taskById = {};\nlet taskCounter = 0;\n\nfunction assert(cond, str) {\n  if (!cond) throw new Error(str);\n}\n\n// Convert raw pixel data to BMP.\n// Based on canvas-to-bmp ((c) 2015 Ken \"Epistemex\" Fyrstenberg, MIT).\nfunction rgba2bmp(ab, w, h) {\n  // helper methods to move current buffer position\n  function setU16(v) {view.setUint16(pos, v, true); pos += 2;}\n  function setU32(v) {view.setUint32(pos, v, true); pos += 4;}\n\n  const headerSize = 54;                             // 14 + 40 bytes\n  const stride = Math.floor((32 * w + 31) / 32) * 3; // row length incl. padding\n  const pixelArraySize = stride * h;                 // total bitmap size\n  const fileLength = headerSize + pixelArraySize;    // header size is known + bitmap\n  const file = new ArrayBuffer(fileLength);          // raw byte buffer (returned)\n  const view = new DataView(file);                   // handle endian, reg. width etc.\n  const data32 = new Uint32Array(ab);                // 32-bit representation of canvas\n  const w3 = w * 3;\n  let pos32 = 0;\n  let pos = 0;\n  let y = 0;\n\n  // write file header\n  setU16(0x4d42);         // BM\n  setU32(fileLength);     // total length\n  pos += 4;               // skip unused fields\n  setU32(headerSize);     // offset to pixels\n\n  // DIB header\n  setU32(40);             // DIB header size\n  setU32(w);              // width\n  setU32(-h >>> 0);       // negative = top-to-bottom\n  setU16(1);              // 1 plane\n  setU16(24);             // 24-bit (RGB)\n  setU32(0);              // no compression (BI_RGB)\n  setU32(pixelArraySize); // bitmap size incl. padding (stride x height)\n  setU32(2835);           // pixels/meter h (~72 DPI x 39.3701 inch/m)\n  setU32(2835);           // pixels/meter v\n\n  // bitmap data, change order of ABGR to BGR\n  while (y < h) {\n    const shift = headerSize + y * stride;\n    let x = 0;\n    while (x < w3) {\n      const abgr = data32[pos32++];\n      const bg = (abgr >> 8) & 0xffff;\n      const r = abgr & 0xff;\n      view.setUint16(shift + x, bg);\n      view.setUint8(shift + x + 2, r);\n      x += 3;\n    }\n    y++;\n  }\n\n  return file;\n}\n\n// Extract OBU.\nfunction avif2obu(ab) {\n  function getU8() {const v = view.getUint8(pos); pos += 1; return v;}\n  function getU16() {const v = view.getUint16(pos); pos += 2; return v;}\n  function getU32() {const v = view.getUint32(pos); pos += 4; return v;}\n\n  const view = new DataView(ab);\n  const len = ab.byteLength;\n  let brandsCheck = false;\n  let pos = 0;\n\n  while (pos < len) {\n    const size = getU32();\n    const type = getU32();\n    const end = pos + size - BOX_HEADER_SIZE;\n    assert(size >= BOX_HEADER_SIZE, \"corrupted file\");\n\n    switch (type) {\n    case BOX_FTYP:\n      // FIXME(Kagami): Check brands.\n      // TODO(Kagami): Also check that meta/hdlr.handler = \"pict\".\n      brandsCheck = true;\n      break;\n    case BOX_META:\n      pos += 1; // version\n      pos += 3; // flags\n      continue;\n    case BOX_ILOC:\n      assert(brandsCheck, \"brands not found\");\n      pos += 1; // version\n      pos += 3; // flags\n      const offsetSizeAndLengthSize = getU8();\n      const offsetSize = offsetSizeAndLengthSize >>> 4;\n      assert(offsetSize < 8, \"unsupported offset size\");\n      const lengthSize = offsetSizeAndLengthSize & 0xf;\n      assert(lengthSize < 8, \"unsupported length size\");\n      const baseOffsetSize = getU8() >>> 4;\n      assert(baseOffsetSize < 8, \"unsupported base offset size\");\n      const itemCount = getU16();\n      assert(itemCount >= 1, \"bad iloc items number\");\n      // XXX(Kagami): Choosing first item for simplicity.\n      // TODO(Kagami): Use primary item (meta/pitm/item_ID).\n      // TODO(Kagami): Also check that meta/iinf/infe[i].item_type = \"av01\".\n      pos += 2; // item_ID\n      pos += 2; // data_reference_index\n      const baseOffset = baseOffsetSize === 4 ? getU32() : 0;\n      pos += 2; // extent_count (>= 1)\n      // XXX(Kagami): What should we do if extent_count > 1?\n      const extentOffset = offsetSize === 4 ? getU32() : 0;\n      const extentLength = lengthSize === 4 ? getU32() : 0;\n      const u8 = new Uint8Array(ab);\n      const offset = baseOffset + extentOffset;\n      return u8.subarray(offset, offset + extentLength);\n    }\n\n    pos = end;\n  }\n\n  throw new Error(\"picture not found\");\n}\n\n// Embed OBU into MOV container stub as video frame.\nfunction obu2mov(obu) {\n  const fileSize = MOV_HEADER_SIZE + obu.byteLength;\n  const ab = new ArrayBuffer(fileSize);\n  const view = new DataView(ab);\n  const u8 = new Uint8Array(ab);\n  u8.set(MOV_HEADER);\n  u8.set(obu, MOV_HEADER_SIZE);\n  // |....|stsz|.|...|xxxx|\n  view.setUint32(MOV_STSZ_OFFSET + BOX_HEADER_SIZE + 4, obu.byteLength);\n  // |xxxx|mdat|\n  view.setUint32(MOV_MDAT_OFFSET, obu.byteLength + BOX_HEADER_SIZE);\n  // FIXME(Kagami): Fix width, height, av1C metadata.\n  return ab;\n}\n\n// Remux AVIF picture as MOV video with single frame.\nfunction avif2mov(ab) {\n  return obu2mov(avif2obu(ab));\n}\n\n// Do preparation work and pass job request to the DOM context.\n// TODO(Kagami): Cache by URL?\nfunction decodeAvif(id, req, client) {\n  // TODO(Kagami): Apply request headers?\n  return fetch(req.url, {credentials: \"same-origin\"})\n    .then(res => res.arrayBuffer())\n    .then(avifArr => {\n      const movArr = avif2mov(avifArr);\n      client.postMessage({id, type: \"avif-mov\", data: movArr}, [movArr]);\n    });\n}\n\n// Handle job responses.\nself.addEventListener(\"message\", e => {\n  const msg = e.data;\n  if (msg && msg.type === \"avif-rgba\") {\n    const bmpArr = rgba2bmp(msg.data, msg.width, msg.height);\n    const blob = new Blob([bmpArr], {type: \"image/bmp\"});\n    // TODO(Kagami): Apply response metadata?\n    const res = new Response(blob);\n    taskById[msg.id].resolve(res);\n  } else if (msg && msg.type === \"avif-error\") {\n    taskById[msg.id].reject(new Error(msg.data));\n  }\n});\n\n// Handle AVIF requests.\n// TODO(Kagami): Timeout for fetching/handling.\nself.addEventListener(\"fetch\", e => {\n  if (!e.clientId) return;\n  // TODO(Kagami): Better check for AVIF. HTTP headers?\n  if (e.request.url.match(/\\.avif$/i)) {\n    const id = taskCounter++;\n    // TODO(Kagami): What should we do in case of error?\n    e.respondWith(new Promise((resolve, reject) => {\n      taskById[id] = {resolve, reject};\n      clients.get(e.clientId)\n        .then(client => decodeAvif(id, e.request, client))\n        .catch(reject);\n    }).then(res => {\n      delete taskById[id];\n      return res;\n    }, err => {\n      delete taskById[id];\n      throw err;\n    }));\n  }\n});\n\n// IIFE\n})();\n"]}