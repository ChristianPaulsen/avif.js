{"version":3,"sources":["../avif-sw.js"],"names":["BOX_HEADER_SIZE","BOX_FTYP","BOX_META","BOX_ILOC","BOX_IPRP","BOX_IPCO","BOX_ISPE","MOV_HEADER","u32","Uint32Array","Uint8Array","buffer","MOV_HEADER_SIZE","byteLength","MOV_STSZ_OFFSET","MOV_MDAT_OFFSET","MOV_TKHD_WIDTH_OFFSET","MOV_AV01_WIDTH_OFFSET","waitForClient","taskById","taskCounter","assert","cond","str","Error","avif2mov","ab","obu2mov","width","height","data","fileSize","ArrayBuffer","view","DataView","u8","set","setUint32","setUint16","avif2obu","getU8","v","getUint8","pos","getU16","getUint16","getU32","getUint32","len","brandsCheck","size","type","end","offsetSizeAndLengthSize","offsetSize","lengthSize","baseOffsetSize","baseOffset","extentOffset","extentLength","offset","subarray","self","addEventListener","e","msg","skipWaiting","clients","claim","cid","source","id","resolve","ready","Promise","bmpArr","rgba2bmp","w","h","setU16","setU32","headerSize","stride","Math","floor","pixelArraySize","fileLength","file","data32","w3","pos32","y","shift","x","abgr","bg","r","setUint8","blob","Blob","res","Response","reject","clientId","request","url","match","respondWith","get","then","client","decodeAvif","req","fetch","credentials","arrayBuffer","avifArr","movArr","postMessage","catch","err"],"mappings":";CAAA,WAGMA,MAAAA,EAAkB,EAClBC,EAAW,WACXC,EAAW,WACXC,EAAW,WACXC,EAAW,WACXC,EAAW,WACXC,EAAW,WAGXC,EAAc,WACZC,MAAAA,EAAM,IAAIC,YAAY,CAAC,UAAU,WAAW,WAAW,OAAO,WAAW,UAAU,UAAU,WAAW,WAAW,WAAW,WAAW,EAAE,EAAE,EAAE,WAAW,UAAU,IAAI,EAAE,EAAE,EAAE,IAAI,EAAE,EAAE,EAAE,IAAI,EAAE,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,SAAS,WAAW,WAAW,WAAW,WAAW,SAAS,EAAE,EAAE,SAAS,EAAE,UAAU,EAAE,EAAE,EAAE,EAAE,IAAI,EAAE,EAAE,EAAE,IAAI,EAAE,EAAE,EAAE,GAAG,MAAM,MAAM,WAAW,WAAW,UAAU,WAAW,EAAE,EAAE,EAAE,WAAW,WAAW,MAAM,UAAU,WAAW,EAAE,EAAE,WAAW,EAAE,EAAE,EAAE,SAAS,WAAW,IAAI,WAAW,IAAI,EAAE,EAAE,EAAE,WAAW,IAAI,WAAW,IAAI,EAAE,EAAE,WAAW,GAAG,EAAE,WAAW,IAAI,WAAW,IAAI,EAAE,EAAE,UAAU,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,SAAS,QAAQ,QAAQ,EAAE,MAAM,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,SAAS,WAAW,WAAW,UAAU,GAAG,WAAW,SAAS,UAAU,WAAW,EAAE,SAAS,SAAS,WAAW,UAAU,WAAW,EAAE,SAAS,SAAS,SAAS,SAAS,UAAU,WAAW,EAAE,EAAE,SAAS,UAAU,WAAW,EAAE,SAAS,WAAW,EAAE,aACh5B,OAAA,IAAIC,WAAWF,EAAIG,QAFR,GAIdC,EAAkBL,EAAWM,WAC7BC,EAAkB,IAClBC,EAAkB,IAClBC,EAAwB,IACxBC,EAAwB,IAGxBC,EAAgB,GAGhBC,EAAW,GACbC,IAAAA,EAAc,EAETC,SAAAA,EAAOC,EAAMC,GAChB,IAACD,EAAM,MAAM,IAAIE,MAAMD,GA6JpBE,SAAAA,EAASC,GACTC,OAtBAA,UAAQ,MAACC,EAAD,OAAQC,EAAR,KAAgBC,IACzBC,MAAAA,EAAWnB,EAAkBkB,EAAKjB,WAClCa,EAAK,IAAIM,YAAYD,GACrBE,EAAO,IAAIC,SAASR,GACpBS,EAAK,IAAIzB,WAAWgB,GAanBA,OAZPS,EAAGC,IAAI7B,GACP4B,EAAGC,IAAIN,EAAMlB,GAEbqB,EAAKI,UAAUvB,EAAkBd,EAAkB,EAAG8B,EAAKjB,YAE3DoB,EAAKI,UAAUtB,EAAiBe,EAAKjB,WAAab,GAElDiC,EAAKI,UAAUrB,EAAuBY,GACtCK,EAAKI,UAAUrB,EAAwB,EAAGa,GAE1CI,EAAKK,UAAUrB,EAAuBW,GACtCK,EAAKK,UAAUrB,EAAwB,EAAGY,GACnCH,EAKAC,CArGAY,SAASb,GACPc,SAAAA,IAAeC,MAAAA,EAAIR,EAAKS,SAASC,GAAuBF,OAAjBE,GAAO,EAAUF,EACxDG,SAAAA,IAAgBH,MAAAA,EAAIR,EAAKY,UAAUF,GAAuBF,OAAjBE,GAAO,EAAUF,EAC1DK,SAAAA,IAAgBL,MAAAA,EAAIR,EAAKc,UAAUJ,GAAuBF,OAAjBE,GAAO,EAAUF,EAE7DR,MAAAA,EAAO,IAAIC,SAASR,GACpBsB,EAAMtB,EAAGb,WACX8B,IAAAA,EAAM,EAENM,GAAc,EACdrB,EAAQ,EACRC,EAAS,EACTC,EAAQ,KAELa,KAAAA,EAAMK,GAAK,CACVE,MAAAA,EAAOJ,IACPK,EAAOL,IACPM,EAAMT,EAAMO,EAAOlD,EAGjBmD,OAFR9B,EAAO6B,GAAQlD,EAAiB,kBAExBmD,GACHlD,KAAAA,EAGHgD,GAAc,EACd,MACG/C,KAAAA,EACHyC,GAAO,EACPA,GAAO,EACP,SACGvC,KAAAA,EAEAC,KAAAA,EACH,SACGC,KAAAA,EACHqC,GAAO,EACPA,GAAO,EACPf,EAAQkB,IACRjB,EAASiB,IACT,MACG3C,KAAAA,EACHwC,GAAO,EACPA,GAAO,EACDU,MAAAA,EAA0Bb,IAC1Bc,EAAaD,IAA4B,EAC/ChC,EAAOiC,EAAa,EAAG,2BACjBC,MAAAA,EAAuC,GAA1BF,EACnBhC,EAAOkC,EAAa,EAAG,2BACjBC,MAAAA,EAAiBhB,MAAY,EACnCnB,EAAOmC,EAAiB,EAAG,gCAE3BnC,EADkBuB,KACE,EAAG,yBAIvBD,GAAO,EACPA,GAAO,EACDc,MAAAA,EAAgC,IAAnBD,EAAuBV,IAAW,EACrDH,GAAO,EAEDe,MAAAA,EAA8B,IAAfJ,EAAmBR,IAAW,EAC7Ca,EAA8B,IAAfJ,EAAmBT,IAAW,EAE7Cc,EAASH,EAAaC,EAC5B5B,EAFW,IAAIpB,WAAWgB,GAEhBmC,SAASD,EAAQA,EAASD,GAItChB,EAAMS,EAMD,OAHP/B,EAAO4B,EAAa,cACpB5B,EAAOO,GAASC,EAAQ,6BACxBR,EAAOS,EAAM,0BACN,CAACF,MAAAA,EAAOC,OAAAA,EAAQC,KAAAA,GA2BRS,CAASb,IAiB1BoC,KAAKC,iBAAiB,UAAWC,IACzBC,MAAAA,EAAMD,EAAElC,KACV,GAACmC,EACDA,GAAa,gBAAbA,EAAId,KACNe,mBACK,GAAiB,eAAbD,EAAId,KACbgB,QAAQC,aACH,GAAiB,eAAbH,EAAId,KAAuB,CAC9BkB,MAAAA,EAAML,EAAEM,OAAOC,GACjBrD,EAAcmD,GAChBnD,EAAcmD,GAAKG,UAEnBtD,EAAcmD,GAAO,CAACI,MAAOC,QAAQF,UAAWA,QAAS,WAEtD,GAAiB,cAAbP,EAAId,KAAsB,CAC7BwB,MAAAA,EAzLDC,SAASlD,EAAImD,EAAGC,GACdC,SAAAA,EAAOtC,GAAIR,EAAKK,UAAUK,EAAKF,GAAG,GAAOE,GAAO,EAChDqC,SAAAA,EAAOvC,GAAIR,EAAKI,UAAUM,EAAKF,GAAG,GAAOE,GAAO,EAEnDsC,MACAC,EAA0C,EAAjCC,KAAKC,OAAO,GAAKP,EAAI,IAAM,IACpCQ,EAAiBH,EAASJ,EAC1BQ,EAHa,GAGaD,EAC1BE,EAAO,IAAIvD,YAAYsD,GACvBrD,EAAO,IAAIC,SAASqD,GACpBC,EAAS,IAAI/E,YAAYiB,GACzB+D,EAAS,EAAJZ,EACPa,IAAAA,EAAQ,EACR/C,EAAM,EACNgD,EAAI,EAoBDA,IAjBPZ,EAAO,OACPC,EAAOM,GACP3C,GAAO,EACPqC,EAhBmB,IAmBnBA,EAAO,IACPA,EAAOH,GACPG,GAAQF,IAAM,GACdC,EAAO,GACPA,EAAO,IACPC,EAAO,GACPA,EAAOK,GACPL,EAAO,MACPA,EAAO,MAGAW,EAAIb,GAAG,CACNc,MAAAA,EA/BW,GA+BUD,EAAIT,EAC3BW,IAAAA,EAAI,EACDA,KAAAA,EAAIJ,GAAI,CACPK,MAAAA,EAAON,EAAOE,KACdK,EAAMD,GAAQ,EAAK,MACnBE,EAAW,IAAPF,EACV7D,EAAKK,UAAUsD,EAAQC,EAAGE,GAC1B9D,EAAKgE,SAASL,EAAQC,EAAI,EAAGG,GAC7BH,GAAK,EAEPF,IAGKJ,OAAAA,EAyIUX,CAASX,EAAInC,KAAMmC,EAAIrC,MAAOqC,EAAIpC,QAC3CqE,EAAO,IAAIC,KAAK,CAACxB,GAAS,CAACxB,KAAM,cAEjCiD,EAAM,IAAIC,SAASH,GACzB/E,EAAS8C,EAAIM,KAAOpD,EAAS8C,EAAIM,IAAIC,QAAQ4B,OACvB,eAAbnC,EAAId,MACbhC,EAAS8C,EAAIM,KAAOpD,EAAS8C,EAAIM,IAAI+B,OAAO,IAAI9E,MAAMyC,EAAInC,SAM9DgC,KAAKC,iBAAiB,QAASC,IACvBK,MAAAA,EAAML,EAAEuC,SAEVvC,GAAAA,EAAEwC,QAAQC,IAAIC,MAAM,YAAa,CAC/B,IAACxF,EAAcmD,GAAM,CACnBG,IAAAA,EAAU,KACVC,EAAQ,IAAIC,QAAQ0B,IAAS5B,EAAU4B,IAC3ClF,EAAcmD,GAAO,CAACI,MAAAA,EAAOD,QAAAA,GAEzBD,MAAAA,EAAKnD,IACX4C,EAAE2C,YAAY,IAAIjC,QAAQ,CAACF,EAAS8B,KAClCnF,EAASoD,GAAM,CAACC,QAAAA,EAAS8B,OAAAA,GACzBnC,QAAQyC,IAAIvC,GACTwC,KAAKC,IArDLC,SAAWxC,EAAIyC,EAAKF,GAEpBG,OAAAA,MAAMD,EAAIP,IAAK,CAACS,YAAa,gBACjCL,KAAKT,GAAOA,EAAIe,eAChBN,KAAKO,IACEC,MAAAA,EAAS5F,EAAS2F,GACxBlG,EAAc4F,EAAOvC,IAAIE,MAAMoC,KAAK,KAClCC,EAAOQ,YAAY,CAAC/C,GAAAA,EAAIpB,KAAM,WAAYrB,KAAMuF,GAAS,CAACA,SA8C1CN,CAAWxC,EAAIP,EAAEwC,QAASM,IACzCS,MAAMjB,KACRO,KAAKT,WACCjF,EAASoD,GACT6B,GACNoB,IAEKA,aADCrG,EAASoD,GACViD,QA5PZ","file":"avif-sw.map","sourceRoot":"../../home/kagami/code/avif.js/demo","sourcesContent":["(function() {\n\n// ISOBMFF constants.\nconst BOX_HEADER_SIZE = 8;\nconst BOX_FTYP = 0x66747970;\nconst BOX_META = 0x6d657461;\nconst BOX_ILOC = 0x696c6f63;\nconst BOX_IPRP = 0x69707270;\nconst BOX_IPCO = 0x6970636f;\nconst BOX_ISPE = 0x69737065;\n\n// MOV container stub with single video track.\nconst MOV_HEADER = (function() {\n  const u32 = new Uint32Array([469762048,1887007846,1836020585,131072,1836020585,846164841,825520237,1140981760,1987014509,1811939328,1684567661,0,0,0,3892510720,704643072,256,1,0,0,256,0,0,0,256,0,0,0,64,0,0,0,0,0,0,33554432,3489726464,1801548404,1543503872,1684564852,50331648,0,0,16777216,0,704643072,0,0,0,0,256,0,0,0,256,0,0,0,64,32775,14340,1812004864,1634296941,536870912,1684563053,0,0,0,3227320320,3909287936,50261,553648128,1919706216,0,0,1701079414,0,0,0,16777216,1852402979,102,1752004116,100,1,0,0,1852400676,102,1701995548,102,0,1,1819440396,32,1,1651799011,108,1937011583,100,0,1,813064559,49,0,1,0,0,0,75499264,4718648,4718592,0,65536,0,0,0,0,0,0,0,0,16776984,1629028352,2168664438,167775240,11,3284118338,31915895,402653184,1937011827,0,16777216,16777216,3909287936,469762048,1668510835,0,16777216,16777216,16777216,16777216,335544320,2054386803,0,0,16777216,335544320,1868788851,0,16777216,1744961536,0,1952539757]);\n  return new Uint8Array(u32.buffer);\n})();\nconst MOV_HEADER_SIZE = MOV_HEADER.byteLength;\nconst MOV_STSZ_OFFSET = 568;\nconst MOV_MDAT_OFFSET = 608;\nconst MOV_TKHD_WIDTH_OFFSET = 234;\nconst MOV_AV01_WIDTH_OFFSET = 437;\n\n// Wait for client to become ready.\nconst waitForClient = {};\n\n// Pending tasks.\nconst taskById = {};\nlet taskCounter = 0;\n\nfunction assert(cond, str) {\n  if (!cond) throw new Error(str);\n}\n\n// Convert raw pixel data to BMP.\n// Based on canvas-to-bmp ((c) 2015 Ken \"Epistemex\" Fyrstenberg, MIT).\nfunction rgba2bmp(ab, w, h) {\n  function setU16(v) {view.setUint16(pos, v, true); pos += 2;}\n  function setU32(v) {view.setUint32(pos, v, true); pos += 4;}\n\n  const headerSize = 54;                             // 14 + 40 bytes\n  const stride = Math.floor((32 * w + 31) / 32) * 3; // row length incl. padding\n  const pixelArraySize = stride * h;                 // total bitmap size\n  const fileLength = headerSize + pixelArraySize;    // header size is known + bitmap\n  const file = new ArrayBuffer(fileLength);          // raw byte buffer (returned)\n  const view = new DataView(file);                   // handle endian, reg. width etc.\n  const data32 = new Uint32Array(ab);                // 32-bit representation of canvas\n  const w3 = w * 3;\n  let pos32 = 0;\n  let pos = 0;\n  let y = 0;\n\n  // BMP header.\n  setU16(0x4d42);         // BM\n  setU32(fileLength);     // total length\n  pos += 4;               // skip unused fields\n  setU32(headerSize);     // offset to pixels\n\n  // DIB header.\n  setU32(40);             // DIB header size\n  setU32(w);              // width\n  setU32(-h >>> 0);       // negative = top-to-bottom\n  setU16(1);              // 1 plane\n  setU16(24);             // 24-bit (RGB)\n  setU32(0);              // no compression (BI_RGB)\n  setU32(pixelArraySize); // bitmap size incl. padding (stride x height)\n  setU32(2835);           // pixels/meter h (~72 DPI x 39.3701 inch/m)\n  setU32(2835);           // pixels/meter v\n\n  // Bitmap data, change order from ABGR to BGR.\n  while (y < h) {\n    const shift = headerSize + y * stride;\n    let x = 0;\n    while (x < w3) {\n      const abgr = data32[pos32++];\n      const bg = (abgr >> 8) & 0xffff;\n      const r = abgr & 0xff;\n      view.setUint16(shift + x, bg);\n      view.setUint8(shift + x + 2, r);\n      x += 3;\n    }\n    y++;\n  }\n\n  return file;\n}\n\n// Extract OBU.\nfunction avif2obu(ab) {\n  function getU8() {const v = view.getUint8(pos); pos += 1; return v;}\n  function getU16() {const v = view.getUint16(pos); pos += 2; return v;}\n  function getU32() {const v = view.getUint32(pos); pos += 4; return v;}\n\n  const view = new DataView(ab);\n  const len = ab.byteLength;\n  let pos = 0;\n\n  let brandsCheck = false;\n  let width = 0;\n  let height = 0;\n  let data =  null;\n\n  while (pos < len) {\n    const size = getU32();\n    const type = getU32();\n    const end = pos + size - BOX_HEADER_SIZE;\n    assert(size >= BOX_HEADER_SIZE, \"corrupted file\");\n\n    switch (type) {\n    case BOX_FTYP:\n      // FIXME(Kagami): Check brands.\n      // TODO(Kagami): Also check that meta/hdlr.handler = \"pict\".\n      brandsCheck = true;\n      break;\n    case BOX_META:\n      pos += 1; // version\n      pos += 3; // flags\n      continue;\n    case BOX_IPRP:\n      continue;\n    case BOX_IPCO:\n      continue;\n    case BOX_ISPE:\n      pos += 1; // version\n      pos += 3; // flags\n      width = getU32();\n      height = getU32();\n      break;\n    case BOX_ILOC:\n      pos += 1; // version\n      pos += 3; // flags\n      const offsetSizeAndLengthSize = getU8();\n      const offsetSize = offsetSizeAndLengthSize >>> 4;\n      assert(offsetSize < 8, \"unsupported offset size\");\n      const lengthSize = offsetSizeAndLengthSize & 0xf;\n      assert(lengthSize < 8, \"unsupported length size\");\n      const baseOffsetSize = getU8() >>> 4;\n      assert(baseOffsetSize < 8, \"unsupported base offset size\");\n      const itemCount = getU16();\n      assert(itemCount >= 1, \"bad iloc items number\");\n      // XXX(Kagami): Choosing first item for simplicity.\n      // TODO(Kagami): Use primary item (meta/pitm/item_ID).\n      // TODO(Kagami): Also check that meta/iinf/infe[i].item_type = \"av01\".\n      pos += 2; // item_ID\n      pos += 2; // data_reference_index\n      const baseOffset = baseOffsetSize === 4 ? getU32() : 0;\n      pos += 2; // extent_count (>= 1)\n      // XXX(Kagami): What should we do if extent_count > 1?\n      const extentOffset = offsetSize === 4 ? getU32() : 0;\n      const extentLength = lengthSize === 4 ? getU32() : 0;\n      const u8 = new Uint8Array(ab);\n      const offset = baseOffset + extentOffset;\n      data = u8.subarray(offset, offset + extentLength);\n      break;\n    }\n\n    pos = end;\n  }\n\n  assert(brandsCheck, \"bad brands\");\n  assert(width && height, \"bad image width or height\");\n  assert(data, \"picture data not found\");\n  return {width, height, data};\n}\n\n// Embed OBU into MOV container stub as video frame.\n// TODO(Kagami): Fix matrix, bitdepth, av1C metadata.\nfunction obu2mov({width, height, data}) {\n  const fileSize = MOV_HEADER_SIZE + data.byteLength;\n  const ab = new ArrayBuffer(fileSize);\n  const view = new DataView(ab);\n  const u8 = new Uint8Array(ab);\n  u8.set(MOV_HEADER);\n  u8.set(data, MOV_HEADER_SIZE);\n  // |....|stsz|.|...|xxxx|\n  view.setUint32(MOV_STSZ_OFFSET + BOX_HEADER_SIZE + 4, data.byteLength);\n  // |xxxx|mdat|\n  view.setUint32(MOV_MDAT_OFFSET, data.byteLength + BOX_HEADER_SIZE);\n  // |xxxx|xxxx|\n  view.setUint32(MOV_TKHD_WIDTH_OFFSET, width);\n  view.setUint32(MOV_TKHD_WIDTH_OFFSET + 4, height);\n  // |xx|xx|\n  view.setUint16(MOV_AV01_WIDTH_OFFSET, width);\n  view.setUint16(MOV_AV01_WIDTH_OFFSET + 2, height);\n  return ab;\n}\n\n// Remux AVIF picture as MOV video with single frame.\nfunction avif2mov(ab) {\n  return obu2mov(avif2obu(ab));\n}\n\n// Do preparation work and pass job request to DOM context.\nfunction decodeAvif(id, req, client) {\n  // TODO(Kagami): Apply request headers?\n  return fetch(req.url, {credentials: \"same-origin\"})\n    .then(res => res.arrayBuffer())\n    .then(avifArr => {\n      const movArr = avif2mov(avifArr);\n      waitForClient[client.id].ready.then(() => {\n        client.postMessage({id, type: \"avif-mov\", data: movArr}, [movArr]);\n      });\n    });\n}\n\n// Handle job responses.\nself.addEventListener(\"message\", e => {\n  const msg = e.data;\n  if (!msg) return;\n  if (msg.type === \"avif-update\") {\n    skipWaiting();\n  } else if (msg.type === \"avif-claim\") {\n    clients.claim();\n  } else if (msg.type === \"avif-ready\") {\n    const cid = e.source.id;\n    if (waitForClient[cid]) {\n      waitForClient[cid].resolve();\n    } else {\n      waitForClient[cid] = {ready: Promise.resolve(), resolve: null};\n    }\n  } else if (msg.type === \"avif-rgba\") {\n    const bmpArr = rgba2bmp(msg.data, msg.width, msg.height);\n    const blob = new Blob([bmpArr], {type: \"image/bmp\"});\n    // TODO(Kagami): Apply response metadata?\n    const res = new Response(blob);\n    taskById[msg.id] && taskById[msg.id].resolve(res);\n  } else if (msg.type === \"avif-error\") {\n    taskById[msg.id] && taskById[msg.id].reject(new Error(msg.data));\n  }\n});\n\n// Handle AVIF requests.\n// TODO(Kagami): Error reporting?\nself.addEventListener(\"fetch\", e => {\n  const cid = e.clientId;\n  // TODO(Kagami): Better check for AVIF. HTTP headers?\n  if (e.request.url.match(/\\.avif$/i)) {\n    if (!waitForClient[cid]) {\n      let resolve = null;\n      let ready = new Promise(res => { resolve = res; });\n      waitForClient[cid] = {ready, resolve};\n    }\n    const id = taskCounter++;\n    e.respondWith(new Promise((resolve, reject) => {\n      taskById[id] = {resolve, reject};\n      clients.get(cid)\n        .then(client => decodeAvif(id, e.request, client))\n        .catch(reject);\n    }).then(res => {\n      delete taskById[id];\n      return res;\n    }, err => {\n      delete taskById[id];\n      throw err;\n    }));\n  }\n});\n\n// IIFE\n})();\n"]}