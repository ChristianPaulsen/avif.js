{"version":3,"sources":["../node_modules/dav1d.js/dav1d.js","../bmp.js","../mov.js","../avif-sw.js"],"names":["TOTAL_MEMORY","TOTAL_STACK","PAGE_SIZE","TABLE_SIZE","getRuntime","dynamicTop","table","WebAssembly","Table","initial","maximum","element","memory","Memory","HEAPU8","Uint8Array","buffer","sbrk","increment","oldDynamicTop","emscripten_memcpy_big","dest","src","num","set","subarray","pthread_cond_wait","cond","mutex","pthread_cond_signal","pthread_cond_destroy","pthread_cond_init","attr","pthread_cond_broadcast","pthread_join","thread","res","pthread_create","func","arg","fetchAndInstantiate","data","url","imports","instantiate","req","fetch","credentials","instantiateStreaming","then","arrayBuffer","create","opts","wasmURL","wasmData","Promise","reject","Error","runtime","env","wasm","d","Dav1d","_init","DJS_FORMAT_YUV","DJS_FORMAT_BMP","constructor","FFI","instance","exports","ref","lastFrameRef","djs_init","_decodeFrame","obu","format","unsafe","ArrayBuffer","isView","obuRef","djs_alloc_obu","byteLength","frameRef","djs_decode_obu","frameInfo","Uint32Array","width","height","size","dataRef","srcData","djs_free_frame","decodeFrameAsYUV","decodeFrameAsBMP","unsafeDecodeFrameAsYUV","unsafeDecodeFrameAsBMP","unsafeCleanup","rgba2bmp","ab","w","h","setU16","v","view","setUint16","pos","setU32","setUint32","headerSize","stride","Math","floor","pixelArraySize","fileLength","file","DataView","data32","w3","pos32","y","shift","x","abgr","bg","r","setUint8","BOX_HEADER_SIZE","BOX_FTYP","BOX_META","BOX_ILOC","BOX_IPRP","BOX_IPCO","BOX_ISPE","MOV_HEADER","u32","MOV_HEADER_SIZE","MOV_STSZ_OFFSET","MOV_MDAT_OFFSET","MOV_TKHD_WIDTH_OFFSET","MOV_AV01_WIDTH_OFFSET","assert","str","avif2obu","getU8","getUint8","getU16","getUint16","getU32","getUint32","len","brandsCheck","type","end","offsetSizeAndLengthSize","offsetSize","lengthSize","baseOffsetSize","baseOffset","extentOffset","extentLength","offset","obu2mov","fileSize","u8","avif2mov","waitForClient","taskById","taskCounter","dCtx","initPolyfill","usePolyfill","dav1d","resolve","setClientReady","cid","ready","setClientWaiting","resolveTask","taskId","cb","task","toBlob","rejectTask","err","arr2blob","bmpArr","Blob","nativeDecodeAvif","client","id","avifArr","movArr","postMessage","polyfillDecodeAvif","obuArr","blob","decodeAvif","self","addEventListener","e","msg","skipWaiting","clients","claim","source","message","request","match","clientId","respondWith","get","catch","Response"],"mappings":"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","file":"avif-sw.js","sourceRoot":"../../home/kagami/code/avif.js/demo","sourcesContent":["// Must be in sync with emcc settings!\nconst TOTAL_MEMORY = 64 * 1024 * 1024; // TODO(Kagami): Find optimal amount\nconst TOTAL_STACK = 5626096; // TODO(Kagami): Find why bigger than 5MB\nconst PAGE_SIZE = 64 * 1024;\nconst TABLE_SIZE = 271; // NOTE(Kagami): Depends on the number of\n                        // function pointers in target library, seems\n                        // like no way to know in general case\n\nfunction getRuntime() {\n  let dynamicTop = TOTAL_STACK;\n  const table = new WebAssembly.Table({\n    initial: TABLE_SIZE,\n    maximum: TABLE_SIZE,\n    element: \"anyfunc\",\n  });\n  const memory = new WebAssembly.Memory({\n    initial: TOTAL_MEMORY / PAGE_SIZE,\n    maximum: TOTAL_MEMORY / PAGE_SIZE,\n  });\n  const HEAPU8 = new Uint8Array(memory.buffer);\n  return {\n    table: table,\n    memory: memory,\n    sbrk: (increment) => {\n      const oldDynamicTop = dynamicTop;\n      dynamicTop += increment;\n      return oldDynamicTop;\n    },\n    emscripten_memcpy_big: (dest, src, num) => {\n      HEAPU8.set(HEAPU8.subarray(src, src+num), dest);\n    },\n    // Empty stubs for dav1d.\n    pthread_cond_wait: (cond, mutex) => 0,\n    pthread_cond_signal: (cond) => 0,\n    pthread_cond_destroy: (cond) => 0,\n    pthread_cond_init: (cond, attr) => 0,\n    pthread_cond_broadcast: (cond) => 0,\n    pthread_join: (thread, res) => 0,\n    pthread_create: (thread, attr, func, arg) => 0,\n    // Emscripten debug.\n    // abort: () => {},\n    // __lock: () => {},\n    // __unlock: () => {},\n    // djs_log: (msg) => console.log(msg),\n  };\n}\n\nfunction fetchAndInstantiate(data, url, imports) {\n  if (data) return WebAssembly.instantiate(data, imports);\n  const req = fetch(url, {credentials: \"same-origin\"});\n  if (WebAssembly.instantiateStreaming) {\n    return WebAssembly.instantiateStreaming(req, imports);\n  } else {\n    return req\n      .then(res => res.arrayBuffer())\n      .then(data => WebAssembly.instantiate(data, imports));\n  }\n}\n\nexport function create(opts = {}) {\n  if (!opts.wasmURL && !opts.wasmData) {\n    return Promise.reject(new Error(\"Either wasmURL or wasmData shall be provided\"));\n  }\n  const runtime = getRuntime();\n  const imports = {env: runtime};\n  return fetchAndInstantiate(opts.wasmData, opts.wasmURL, imports).then(wasm => {\n    const d = new Dav1d({wasm, runtime});\n    d._init();\n    return d;\n  });\n}\n\nconst DJS_FORMAT_YUV = 0;\nconst DJS_FORMAT_BMP = 1;\n\nclass Dav1d {\n  /* Private methods, shall not be used */\n\n  constructor({wasm, runtime}) {\n    this.FFI = wasm.instance.exports;\n    this.buffer = runtime.memory.buffer;\n    this.HEAPU8 = new Uint8Array(this.buffer);\n    this.ref = null;\n    this.lastFrameRef = null;\n  }\n  _init() {\n    this.ref = this.FFI.djs_init();\n    if (!this.ref) throw new Error(\"error in djs_init\");\n  }\n  _decodeFrame(obu, format, unsafe) {\n    if (!ArrayBuffer.isView(obu)) {\n      obu = new Uint8Array(obu);\n    }\n    const obuRef = this.FFI.djs_alloc_obu(obu.byteLength);\n    if (!obuRef) throw new Error(\"error in djs_alloc_obu\");\n    this.HEAPU8.set(obu, obuRef);\n    const frameRef = this.FFI.djs_decode_obu(this.ref, obuRef, obu.byteLength, format);\n    if (!frameRef) throw new Error(\"error in djs_decode\");\n    const frameInfo = new Uint32Array(this.buffer, frameRef, 4);\n    const width = frameInfo[0];\n    const height = frameInfo[1];\n    const size = frameInfo[2];\n    const dataRef = frameInfo[3];\n    const srcData = new Uint8Array(this.buffer, dataRef, size);\n    if (unsafe) {\n      this.lastFrameRef = frameRef;\n      return srcData;\n    }\n    const data = new Uint8Array(size);\n    data.set(srcData);\n    this.FFI.djs_free_frame(frameRef);\n    return {width, height, data};\n  }\n\n  /* Public API methods */\n\n  /**\n   * Frame decoding, copy of frame data is returned.\n   */\n  decodeFrameAsYUV(obu) {\n    return this._decodeFrame(obu, DJS_FORMAT_YUV, false);\n  }\n  decodeFrameAsBMP(obu) {\n    return this._decodeFrame(obu, DJS_FORMAT_BMP, false);\n  }\n\n  /**\n   * Unsafe decoding with minimal overhead, pointer to WebAssembly\n   * memory is returned. User can't call any dav1d.js methods while\n   * keeping reference to it and shall call `unsafeCleanup` when\n   * finished using the data.\n   */\n  unsafeDecodeFrameAsYUV(obu) {\n    return this._decodeFrame(obu, DJS_FORMAT_YUV, true);\n  }\n  unsafeDecodeFrameAsBMP(obu) {\n    return this._decodeFrame(obu, DJS_FORMAT_BMP, true);\n  }\n  unsafeCleanup() {\n    if (this.lastFrameRef) {\n      this.FFI.djs_free_frame(this.lastFrameRef);\n      this.lastFrameRef = null;\n    }\n  }\n}\n\nexport default {create};\n","// Convert raw pixel data to BMP.\n// Based on canvas-to-bmp ((c) 2015 Ken \"Epistemex\" Fyrstenberg, MIT).\nexport function rgba2bmp(ab, w, h) {\n  function setU16(v) {view.setUint16(pos, v, true); pos += 2;}\n  function setU32(v) {view.setUint32(pos, v, true); pos += 4;}\n\n  const headerSize = 54;                             // 14 + 40 bytes\n  const stride = Math.floor((24 * w + 31) / 32) * 4; // row length incl. padding\n  const pixelArraySize = stride * h;                 // total bitmap size\n  const fileLength = headerSize + pixelArraySize;    // header size is known + bitmap\n  const file = new ArrayBuffer(fileLength);          // raw byte buffer (returned)\n  const view = new DataView(file);                   // handle endian, reg. width etc.\n  const data32 = new Uint32Array(ab);                // 32-bit representation of canvas\n  const w3 = w * 3;\n  let pos32 = 0;\n  let pos = 0;\n  let y = 0;\n\n  // BMP header.\n  setU16(0x4d42);         // BM\n  setU32(fileLength);     // total length\n  pos += 4;               // skip unused fields\n  setU32(headerSize);     // offset to pixels\n\n  // DIB header.\n  setU32(40);             // DIB header size\n  setU32(w);              // width\n  setU32(-h >>> 0);       // negative = top-to-bottom\n  setU16(1);              // 1 plane\n  setU16(24);             // 24-bit (RGB)\n  setU32(0);              // no compression (BI_RGB)\n  setU32(pixelArraySize); // bitmap size incl. padding (stride x height)\n  setU32(2835);           // pixels/meter h (~72 DPI x 39.3701 inch/m)\n  setU32(2835);           // pixels/meter v\n\n  // Bitmap data, change order from ABGR to BGR.\n  while (y < h) {\n    const shift = headerSize + y * stride;\n    let x = 0;\n    while (x < w3) {\n      const abgr = data32[pos32++];\n      const bg = (abgr >> 8) & 0xffff;\n      const r = abgr & 0xff;\n      view.setUint16(shift + x, bg);\n      view.setUint8(shift + x + 2, r);\n      x += 3;\n    }\n    y++;\n  }\n\n  return file;\n}\n","// ISOBMFF constants.\nconst BOX_HEADER_SIZE = 8;\nconst BOX_FTYP = 0x66747970;\nconst BOX_META = 0x6d657461;\nconst BOX_ILOC = 0x696c6f63;\nconst BOX_IPRP = 0x69707270;\nconst BOX_IPCO = 0x6970636f;\nconst BOX_ISPE = 0x69737065;\n\n// MOV container stub with single video track.\nconst MOV_HEADER = (function() {\n  const u32 = new Uint32Array([469762048,1887007846,1836020585,131072,1836020585,846164841,825520237,1140981760,1987014509,1811939328,1684567661,0,0,0,3892510720,704643072,256,1,0,0,256,0,0,0,256,0,0,0,64,0,0,0,0,0,0,33554432,3489726464,1801548404,1543503872,1684564852,50331648,0,0,16777216,0,704643072,0,0,0,0,256,0,0,0,256,0,0,0,64,32775,14340,1812004864,1634296941,536870912,1684563053,0,0,0,3227320320,3909287936,50261,553648128,1919706216,0,0,1701079414,0,0,0,16777216,1852402979,102,1752004116,100,1,0,0,1852400676,102,1701995548,102,0,1,1819440396,32,1,1651799011,108,1937011583,100,0,1,813064559,49,0,1,0,0,0,75499264,4718648,4718592,0,65536,0,0,0,0,0,0,0,0,16776984,1629028352,2168664438,167775240,11,3284118338,31915895,402653184,1937011827,0,16777216,16777216,3909287936,469762048,1668510835,0,16777216,16777216,16777216,16777216,335544320,2054386803,0,0,16777216,335544320,1868788851,0,16777216,1744961536,0,1952539757]);\n  return new Uint8Array(u32.buffer);\n})();\nconst MOV_HEADER_SIZE = MOV_HEADER.byteLength;\nconst MOV_STSZ_OFFSET = 568;\nconst MOV_MDAT_OFFSET = 608;\nconst MOV_TKHD_WIDTH_OFFSET = 234;\nconst MOV_AV01_WIDTH_OFFSET = 437;\n\nfunction assert(cond, str) {\n  if (!cond) throw new Error(str);\n}\n\n// Extract OBU.\nexport function avif2obu(ab) {\n  function getU8() {const v = view.getUint8(pos); pos += 1; return v;}\n  function getU16() {const v = view.getUint16(pos); pos += 2; return v;}\n  function getU32() {const v = view.getUint32(pos); pos += 4; return v;}\n\n  const view = new DataView(ab);\n  const len = ab.byteLength;\n  let pos = 0;\n\n  let brandsCheck = false;\n  let width = 0;\n  let height = 0;\n  let data =  null;\n\n  while (pos < len) {\n    const size = getU32();\n    const type = getU32();\n    const end = pos + size - BOX_HEADER_SIZE;\n    assert(size >= BOX_HEADER_SIZE, \"corrupted file\");\n\n    // TODO(Kagami): Add box version checks!\n    switch (type) {\n    case BOX_FTYP:\n      // FIXME(Kagami): Check brands.\n      // TODO(Kagami): Also check that meta/hdlr.handler = \"pict\".\n      brandsCheck = true;\n      break;\n    case BOX_META:\n      pos += 1; // version\n      pos += 3; // flags\n      continue;\n    case BOX_IPRP:\n      continue;\n    case BOX_IPCO:\n      continue;\n    case BOX_ISPE:\n      pos += 1; // version\n      pos += 3; // flags\n      width = getU32();\n      height = getU32();\n      break;\n    case BOX_ILOC:\n      pos += 1; // version\n      pos += 3; // flags\n      const offsetSizeAndLengthSize = getU8();\n      const offsetSize = offsetSizeAndLengthSize >>> 4;\n      assert(offsetSize < 8, \"unsupported offset size\");\n      const lengthSize = offsetSizeAndLengthSize & 0xf;\n      assert(lengthSize < 8, \"unsupported length size\");\n      const baseOffsetSize = getU8() >>> 4;\n      assert(baseOffsetSize < 8, \"unsupported base offset size\");\n      const itemCount = getU16();\n      assert(itemCount >= 1, \"bad iloc items number\");\n      // XXX(Kagami): Choosing first item for simplicity.\n      // TODO(Kagami): Use primary item (meta/pitm/item_ID).\n      // TODO(Kagami): Also check that meta/iinf/infe[i].item_type = \"av01\".\n      pos += 2; // item_ID\n      pos += 2; // data_reference_index\n      const baseOffset = baseOffsetSize === 4 ? getU32() : 0;\n      pos += 2; // extent_count (>= 1)\n      // XXX(Kagami): What should we do if extent_count > 1?\n      const extentOffset = offsetSize === 4 ? getU32() : 0;\n      const extentLength = lengthSize === 4 ? getU32() : 0;\n      const u8 = new Uint8Array(ab);\n      const offset = baseOffset + extentOffset;\n      data = u8.subarray(offset, offset + extentLength);\n      break;\n    }\n\n    pos = end;\n  }\n\n  assert(brandsCheck, \"bad brands\");\n  assert(width && height, \"bad image width or height\");\n  assert(data, \"picture data not found\");\n  return {width, height, data};\n}\n\n// Embed OBU into MOV container stub as video frame.\n// TODO(Kagami): Fix matrix, bitdepth, av1C metadata.\nexport function obu2mov({width, height, data}) {\n  const fileSize = MOV_HEADER_SIZE + data.byteLength;\n  const ab = new ArrayBuffer(fileSize);\n  const view = new DataView(ab);\n  const u8 = new Uint8Array(ab);\n  u8.set(MOV_HEADER);\n  u8.set(data, MOV_HEADER_SIZE);\n  // |....|stsz|.|...|xxxx|\n  view.setUint32(MOV_STSZ_OFFSET + BOX_HEADER_SIZE + 4, data.byteLength);\n  // |xxxx|mdat|\n  view.setUint32(MOV_MDAT_OFFSET, data.byteLength + BOX_HEADER_SIZE);\n  // |xxxx|xxxx|\n  view.setUint32(MOV_TKHD_WIDTH_OFFSET, width);\n  view.setUint32(MOV_TKHD_WIDTH_OFFSET + 4, height);\n  // |xx|xx|\n  view.setUint16(MOV_AV01_WIDTH_OFFSET, width);\n  view.setUint16(MOV_AV01_WIDTH_OFFSET + 2, height);\n  return ab;\n}\n\n// Remux AVIF picture as MOV video with single frame.\nexport function avif2mov(ab) {\n  return obu2mov(avif2obu(ab));\n}\n","import dav1d from \"dav1d.js\";\nimport {rgba2bmp} from \"./bmp\";\nimport {avif2obu, avif2mov} from \"./mov\";\n\n// Wait for client to become ready.\nconst waitForClient = {};\n\n// Pending tasks.\nconst taskById = {};\nlet taskCounter = 0;\n\n// AV1 decoder context.\nlet dCtx = null;\n\nfunction initPolyfill(opts) {\n  if (!opts.usePolyfill) return Promise.resolve();\n  return dav1d.create({wasmURL: opts.wasmURL}).then(d => {\n    dCtx = d;\n  });\n}\n\nfunction setClientReady(cid) {\n  if (waitForClient[cid]) {\n    waitForClient[cid].resolve();\n  } else {\n    waitForClient[cid] = {ready: Promise.resolve(), resolve: null};\n  }\n}\n\nfunction setClientWaiting(cid) {\n  if (!waitForClient[cid]) {\n    let resolve = null;\n    let ready = new Promise(res => { resolve = res; });\n    waitForClient[cid] = {ready, resolve};\n  }\n}\n\nfunction resolveTask(taskId, cb) {\n  const task = taskById[taskId];\n  if (task) {\n    task.resolve(cb(task.toBlob));\n  }\n}\n\nfunction rejectTask(taskId, err) {\n  const task = taskById[taskId];\n  if (task) {\n    task.reject(err);\n  }\n}\n\nfunction arr2blob(bmpArr) {\n  return new Blob([bmpArr], {type: \"image/bmp\"});\n}\n\nfunction nativeDecodeAvif(client, id, avifArr) {\n  const movArr = avif2mov(avifArr);\n  client.postMessage({id, type: \"avif-mov\", data: movArr}, [movArr]);\n}\n\n// Synchronous but that should be ok.\nfunction polyfillDecodeAvif(client, id, avifArr) {\n  const obuArr = avif2obu(avifArr).data;\n  resolveTask(id, toBlob => {\n    if (toBlob) {\n      // console.time(\"dav1d \"+id);\n      const bmpArr = dCtx.unsafeDecodeFrameAsBMP(obuArr);\n      // console.timeEnd(\"dav1d \"+id);\n      const blob = arr2blob(bmpArr);\n      dCtx.unsafeCleanup();\n      return blob;\n    } else {\n      // Will be transfered so ok to copy.\n      return dCtx.decodeFrameAsBMP(obuArr);\n    }\n  });\n}\n\nfunction decodeAvif(client, id, avifArr) {\n  return waitForClient[client.id].ready.then(() => {\n    return dCtx ? polyfillDecodeAvif(client, id, avifArr)\n                : nativeDecodeAvif(client, id, avifArr);\n  });\n}\n\n// Handle job messages.\nself.addEventListener(\"message\", e => {\n  const msg = e.data;\n  if (!msg) return;\n\n  switch (msg.type) {\n  // Client asks for our update\n  case \"avif-update\":\n    skipWaiting();\n    break;\n\n  // Client asks to activate us right away\n  case \"avif-claim\":\n    clients.claim();\n    break;\n\n  // Client is ready\n  case \"avif-ready\":\n    initPolyfill(msg.data).then(() => setClientReady(e.source.id));\n    break;\n\n  // Client sent task result\n  case \"avif-rgba\":\n    const bmpArr = rgba2bmp(msg.data, msg.width, msg.height);\n    resolveTask(msg.id, toBlob => toBlob ? arr2blob(bmpArr) : bmpArr);\n    break;\n\n  // Client sent task error\n  case \"avif-error\":\n    rejectTask(msg.id, new Error(msg.data));\n    break;\n\n  // Client sent task request\n  case \"avif-task\":\n    const client = e.source;\n    const id = msg.id;\n    new Promise((resolve, reject) => {\n      taskById[id] = {resolve, reject, toBlob: false};\n      decodeAvif(client, id, msg.data);\n    }).then(bmpArr => {\n      delete taskById[id];\n      client.postMessage({id, type: \"avif-task\", data: bmpArr}, [bmpArr]);\n    }, err => {\n      delete taskById[id];\n      client.postMessage({id, type: \"avif-error\", data: err.message});\n    });\n    break;\n  }\n});\n\n// Handle AVIF requests.\n// TODO(Kagami): Error reporting?\nself.addEventListener(\"fetch\", e => {\n  // TODO(Kagami): Better check for AVIF. HTTP headers?\n  if (e.request.url.match(/\\.avif$/i)) {\n    const id = taskCounter++;\n    setClientWaiting(e.clientId);\n    e.respondWith(new Promise((resolve, reject) => {\n      taskById[id] = {resolve, reject, toBlob: true};\n      clients.get(e.clientId).then(client =>\n        // TODO(Kagami): Apply request headers?\n        fetch(e.request.url, {credentials: \"same-origin\"})\n          .then(res => res.arrayBuffer())\n          .then(avifArr => decodeAvif(client, id, avifArr))\n      ).catch(reject);\n    }).then(blob => {\n      delete taskById[id];\n      // TODO(Kagami): Apply response metadata?\n      return new Response(blob);\n    }, err => {\n      delete taskById[id];\n      throw err;\n    }));\n  }\n});\n"]}